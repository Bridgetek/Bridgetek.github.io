<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Drawing Graphs on the BT82x &mdash; Drawing Graphs on the BT82x Tutorial  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="#" class="icon icon-home"> Drawing Graphs on the BT82x Tutorial
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">Drawing Graphs on the BT82x</a><ul>
<li><a class="reference internal" href="#bt82x-series-graph-drawing">BT82x Series Graph Drawing</a></li>
<li><a class="reference internal" href="#contents">Contents</a></li>
<li><a class="reference internal" href="#introduction">Introduction</a><ul>
<li><a class="reference internal" href="#scope">Scope</a></li>
<li><a class="reference internal" href="#conventions">Conventions</a></li>
<li><a class="reference internal" href="#intended-audience">Intended Audience</a></li>
<li><a class="reference internal" href="#api-reference-definitions">API Reference Definitions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#graphing-overview">Graphing Overview</a><ul>
<li><a class="reference internal" href="#bargraph">BARGRAPH</a><ul>
<li><a class="reference internal" href="#example">Example</a></li>
<li><a class="reference internal" href="#discussion">Discussion</a></li>
</ul>
</li>
<li><a class="reference internal" href="#line-strip">LINE_STRIP</a><ul>
<li><a class="reference internal" href="#id1">Example</a></li>
<li><a class="reference internal" href="#id2">Discussion</a></li>
</ul>
</li>
<li><a class="reference internal" href="#edge-strip">EDGE_STRIP</a></li>
<li><a class="reference internal" href="#points">POINTS</a></li>
</ul>
</li>
<li><a class="reference internal" href="#advanced-chapter">Advanced Chapter</a><ul>
<li><a class="reference internal" href="#error-bars">Error Bars</a></li>
<li><a class="reference internal" href="#scrolling">Scrolling</a></li>
<li><a class="reference internal" href="#subtractive-overlays">Subtractive Overlays</a><ul>
<li><a class="reference internal" href="#id3">Example</a></li>
<li><a class="reference internal" href="#id4">Discussion</a></li>
</ul>
</li>
<li><a class="reference internal" href="#precomputed-display-list">Precomputed Display List</a><ul>
<li><a class="reference internal" href="#id5">Example</a></li>
<li><a class="reference internal" href="#id6">Discussion</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#appendix-a-revision-history">Appendix A - Revision History</a></li>
</ul>
</li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">Drawing Graphs on the BT82x Tutorial</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="#" class="icon icon-home"></a> &raquo;</li>
      <li>Drawing Graphs on the BT82x</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <a class="reference external image-reference" href="https://brtchip.com"><img alt="BridgeTek" src="https://brtchip.com/wp-content/uploads/2021/07/Bridgetek-logo.png" /></a>
<section id="drawing-graphs-on-the-bt82x">
<h1><a class="toc-backref" href="#id7">Drawing Graphs on the BT82x</a><a class="headerlink" href="#drawing-graphs-on-the-bt82x" title="Permalink to this heading"></a></h1>
<section id="bt82x-series-graph-drawing">
<h2><a class="toc-backref" href="#id8">BT82x Series Graph Drawing</a><a class="headerlink" href="#bt82x-series-graph-drawing" title="Permalink to this heading"></a></h2>
<p>This tutorial describes methods and options for graph drawing on the BT82x.</p>
<p>It uses the <a class="reference external" href="https://github.com/Bridgetek/Eve-MCU-Dev">Eve-MCU-Dev</a> EVE library for embedded MCUs and the <a class="reference external" href="https://github.com/Bridgetek/python-bt82x-dev">python-bt82x-dev</a> library for python.</p>
<p>This project requires a BridgeTek BT82x board and display. It is written to demonstrate methods for drawing graphs on BT82x.</p>
</section>
<section id="contents">
<h2><a class="toc-backref" href="#id9">Contents</a><a class="headerlink" href="#contents" title="Permalink to this heading"></a></h2>
<div class="contents topic" id="table-of-contents">
<p class="topic-title">Table of Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#drawing-graphs-on-the-bt82x" id="id7">Drawing Graphs on the BT82x</a></p>
<ul>
<li><p><a class="reference internal" href="#bt82x-series-graph-drawing" id="id8">BT82x Series Graph Drawing</a></p></li>
<li><p><a class="reference internal" href="#contents" id="id9">Contents</a></p></li>
<li><p><a class="reference internal" href="#introduction" id="id10">Introduction</a></p>
<ul>
<li><p><a class="reference internal" href="#scope" id="id11">Scope</a></p></li>
<li><p><a class="reference internal" href="#conventions" id="id12">Conventions</a></p></li>
<li><p><a class="reference internal" href="#intended-audience" id="id13">Intended Audience</a></p></li>
<li><p><a class="reference internal" href="#api-reference-definitions" id="id14">API Reference Definitions</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#graphing-overview" id="id15">Graphing Overview</a></p>
<ul>
<li><p><a class="reference internal" href="#bargraph" id="id16">BARGRAPH</a></p>
<ul>
<li><p><a class="reference internal" href="#example" id="id17">Example</a></p></li>
<li><p><a class="reference internal" href="#discussion" id="id18">Discussion</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#line-strip" id="id19">LINE_STRIP</a></p>
<ul>
<li><p><a class="reference internal" href="#id1" id="id20">Example</a></p></li>
<li><p><a class="reference internal" href="#id2" id="id21">Discussion</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#edge-strip" id="id22">EDGE_STRIP</a></p></li>
<li><p><a class="reference internal" href="#points" id="id23">POINTS</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#advanced-chapter" id="id24">Advanced Chapter</a></p>
<ul>
<li><p><a class="reference internal" href="#error-bars" id="id25">Error Bars</a></p></li>
<li><p><a class="reference internal" href="#scrolling" id="id26">Scrolling</a></p></li>
<li><p><a class="reference internal" href="#subtractive-overlays" id="id27">Subtractive Overlays</a></p>
<ul>
<li><p><a class="reference internal" href="#id3" id="id28">Example</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id29">Discussion</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#precomputed-display-list" id="id30">Precomputed Display List</a></p>
<ul>
<li><p><a class="reference internal" href="#id5" id="id31">Example</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id32">Discussion</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#appendix-a-revision-history" id="id33">Appendix A - Revision History</a></p></li>
</ul>
</li>
</ul>
</div>
</section>
<section id="introduction">
<h2><a class="toc-backref" href="#id10">Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this heading"></a></h2>
<p>This document captures the programming details for graph drawing with the BT82x Series chips. This document only provides additional information to that found in the BT82X Series Programming Guide.</p>
<p>The methods described here show the options available and relative advantages and disadvantages of each.</p>
<section id="scope">
<h3><a class="toc-backref" href="#id11">Scope</a><a class="headerlink" href="#scope" title="Permalink to this heading"></a></h3>
<p>This document will show suggested methods for displaying graphs.
The BT82x programming guide has information on the standard co-processor commands. Methods described in this document add to the range of available co-processor commands.</p>
</section>
<section id="conventions">
<h3><a class="toc-backref" href="#id12">Conventions</a><a class="headerlink" href="#conventions" title="Permalink to this heading"></a></h3>
<ul class="simple">
<li><p>All values are in decimal by default.</p></li>
<li><p>The values with <strong>0x</strong> are in hexadecimal.</p></li>
<li><p>The values with <strong>0b’</strong> are in binary.</p></li>
<li><p>The endianness of commands, register values, and data in RAM_G are in <strong>little-endian</strong> format.</p></li>
<li><p><strong>Host</strong> refers to the MCU/MPU with SPI master interface connecting with EVE.</p></li>
<li><p><strong>Host Commands</strong> refer to the EVE specific commands defined in the “Host Commands” section in the BT82X Series Programming Guide.</p></li>
<li><p>The phrase “<strong>patch</strong>” is used in this document to refer to a patch file which may contain both code fixes or additional features (extensions).</p></li>
</ul>
</section>
<section id="intended-audience">
<h3><a class="toc-backref" href="#id13">Intended Audience</a><a class="headerlink" href="#intended-audience" title="Permalink to this heading"></a></h3>
<p>The intended audience of this document are Software Programmers and System Designers who develop graphical user interface (GUI) applications on the BT82x series of devices.</p>
</section>
<section id="api-reference-definitions">
<h3><a class="toc-backref" href="#id14">API Reference Definitions</a><a class="headerlink" href="#api-reference-definitions" title="Permalink to this heading"></a></h3>
<p>The following table provides the functionality and nomenclature of the APIs used in this document.</p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 23%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>API</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>wr32()</p></td>
<td><p>Write 32 bits to intended address location |</p></td>
</tr>
<tr class="row-odd"><td><p>rd32()</p></td>
<td><p>Read 32 bits from intended address location |</p></td>
</tr>
<tr class="row-even"><td><p>cmd()</p></td>
<td><p>Write 32 bits data to command FIFO i.e., RAM_CMD |</p></td>
</tr>
<tr class="row-odd"><td><p>cmd_*()</p></td>
<td><p>Write 32 bits command with its necessary parameters to command FIFO i.e., RAM_CMD. |</p></td>
</tr>
<tr class="row-even"><td><p>dl()</p></td>
<td><p>Write 32 bits display list command to RAM_DL. |</p></td>
</tr>
<tr class="row-odd"><td><p>host_command()</p></td>
<td><p>Send host command to EVE |</p></td>
</tr>
</tbody>
</table>
<p><strong>Table 1 – API Reference Definitions</strong></p>
</section>
</section>
<section id="graphing-overview">
<h2><a class="toc-backref" href="#id15">Graphing Overview</a><a class="headerlink" href="#graphing-overview" title="Permalink to this heading"></a></h2>
<p>The BT82x has a built-in BARGRAPH bitmap type that can simplify drawing a simple bargraph style (area under the line shaded) graph as a BITMAP type in a display list.
Other methods of drawing a graph are using a LINE_STRIP or POINTS to show line graphs and point data on a chart.</p>
<section id="bargraph">
<h3><a class="toc-backref" href="#id16">BARGRAPH</a><a class="headerlink" href="#bargraph" title="Permalink to this heading"></a></h3>
<p>The simple BARGRAPH format can be used with a BITMAP primitive to draw an area under shaded graph. This can be scaled, rotated and transformed like any other bitmap type.</p>
<p>It takes a one-dimensional array of 8-bit unsigned data to generate the graph. The source data is stored in RAM_G.</p>
<p>Lower numbers in the source data are higher lines on the graph. Hence the maximum points on the graph will be at 0 in the data-set and the minimum points on the graph will be at 255 in the data-set. A graph can be flipped using transforms to change this or drawn in a background colour over a rectangle of the foreground colour.
The bitmap cell function can be exploited to store multiple graphs within the same bitmap and hence bitmap handle.</p>
<section id="example">
<h4><a class="toc-backref" href="#id17">Example</a><a class="headerlink" href="#example" title="Permalink to this heading"></a></h4>
<p>Here is an example of a BARGRAPH:</p>
<img alt="Simple BARGRAPH Example." src="_images/bargraph.png" />
<p><strong>Figure 9 Simple BARGRAPH Example</strong></p>
<p>The code to turn a one-dimensional data set with 400 points into a graph is as follows:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">BITMAP_HANDLE(0)</span>
<span class="go">BITMAP_SOURCE(0)</span>
<span class="go">BITMAP_SIZE_H(0, 0)</span>
<span class="go">BITMAP_SIZE(NEAREST, BORDER, BORDER, 400, 256)</span>
<span class="go">BITMAP_LAYOUT_H(0, 0)</span>
<span class="go">BITMAP_LAYOUT(BARGRAPH, 400, 1)</span>
<span class="go">BEGIN(BITMAPS)</span>
<span class="go">BITMAPHANDLE(0)</span>
<span class="go">COLOR_RGB(0, 255, 0)</span>
<span class="go">CELL(0)</span>
<span class="go">VERTEX2F(10, 10)</span>
</pre></div>
</div>
<p>The height component of the BITMAP_LAYOUT is set to 1 since that is the height of the data-set. The height component of the BITMAP_SIZE is set to 256 to encompass the full range of the data (i.e. 0 to 255).</p>
<p>The bargraph bitmap is drawn simply with a VERTEX2F or VERTEX2II command as with other bitmaps. The same graphics context applies to these bitmaps as well as other normal bitmaps.</p>
</section>
<section id="discussion">
<h4><a class="toc-backref" href="#id18">Discussion</a><a class="headerlink" href="#discussion" title="Permalink to this heading"></a></h4>
<p>There are benefits and drawbacks to using the BARGRAPH format.</p>
<p>The benefits are:
-       The one-dimensional array can be updated in RAM_G and read directly by the Render Engine to display the graph. No further resources or computations are required.
-       The display list sets up the bitmap properties once allowing the bitmap to be used in subsequent display lists without reconfiguring the bitmap.
-       The CELL or VERTEXT2II command can allow multiple graph bitmaps to be built and stored in the same bitmap handle.
-       The method is fast since there are no intermediate effects and all computations are within the Render Engine.
-       The bitmap of the graph can be scaled, rotated or transformed as with any other bitmap.</p>
<p>There are some drawbacks to this method:
-       The drawn graph is not anti-aliased. This may not be necessary in an application but with care drawing the bitmap a pleasing optical effect can be generated. This is discussed later in the Advanced Chapter.
-       A line graph cannot be shown with this method. A workaround is discussed later in the Advanced Chapter.
-       Changing the scale of an axis requires a bitmap transformation.</p>
</section>
</section>
<section id="line-strip">
<h3><a class="toc-backref" href="#id19">LINE_STRIP</a><a class="headerlink" href="#line-strip" title="Permalink to this heading"></a></h3>
<p>To draw a line graph the natural primitive to use would be the LINE_STRIP method and VERTEX2F commands to draw lines between individual points on a chart. This requires that the display list is filled with commands to draw the line of the line graph.</p>
<p>There is no native type to draw a line graph in this way therefore there needs to be external processing of the data-set to produce the points list.</p>
<section id="id1">
<h4><a class="toc-backref" href="#id20">Example</a><a class="headerlink" href="#id1" title="Permalink to this heading"></a></h4>
<p>Here is an example of a graph drawn with a LINE_STRIP.</p>
<img alt="Simple LINE_STRIP Example." src="_images/linestrip.png" />
<p><strong>Figure 9 Simple LINE_STRIP Example</strong></p>
<p>The code to produce this line graph is as follows:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">COLOR_RGB(255, 0, 0)</span>
<span class="go">REGION(1, 63, 824)</span>
<span class="go">BEGIN(4)</span>
<span class="go">VERTEX2F(14, 319)</span>
<span class="go">VERTEX2F(15, 318)</span>
<span class="go">VERTEX2F(16, 315)</span>
<span class="go">VERTEX2F(17, 316)</span>
<span class="go">VERTEX2F(19, 322)</span>
<span class="go">VERTEX2F(20, 321)</span>
<span class="go">VERTEX2F(21, 324)</span>
<span class="go">VERTEX2F(24, 324)</span>
<span class="go">VERTEX2F(25, 319)</span>
<span class="go">VERTEX2F(26, 312)</span>
<span class="go">VERTEX2F(27, 307)</span>
<span class="go">VERTEX2F(29, 310)</span>
<span class="go">VERTEX2F(30, 312)</span>
<span class="go">…</span>
<span class="go">END()</span>
</pre></div>
</div>
<p>As the code demonstrates each point on the x-axis has a corresponding y-axis address defined by the input data-set.</p>
</section>
<section id="id2">
<h4><a class="toc-backref" href="#id21">Discussion</a><a class="headerlink" href="#id2" title="Permalink to this heading"></a></h4>
<p>There are benefits and drawbacks to using the LINE_STRIP format.</p>
<p>The benefits are:
-       The VERTEX2F points are read directly by the Render Engine to display the graph. No further resources or computations are required.
-       The drawn graph is anti-aliased and can be drawn with a specified width using the LINE_WIDTH command.
-       The line uses all the options in the graphics context including transparency.</p>
<p>There are some drawbacks to this method:
-       The points for the LINE_STRIP have to be computed from a one-dimensional data-set. There is no built-in method of changing the input data to VERTEX2F points.
-       This cannot be used to draw an area-under graph.
-       Since each point used to draw the line takes a VERTEX2F command it can add a relatively large number of instructions to the display list.
-       The VERTEX2F command has 14 bit precision so with some settings of VERTEX_FORMAT and larger graphs there may be a need to add VERTEX_TRANSLATE_X/Y commands to allow the VERTEX2F to address some screen points.</p>
</section>
</section>
<section id="edge-strip">
<h3><a class="toc-backref" href="#id22">EDGE_STRIP</a><a class="headerlink" href="#edge-strip" title="Permalink to this heading"></a></h3>
<p>As an alternative to the BARGRAPH format the same principles applied in the LINE_STRIP method can be changed to (in the simplest case) an EDGE_STRIP_B to make an area under graph from the same data as a LINE_STRIP graph. The edge strip will go to the end of the screen display so a scissor operation is needed to keep the graph within the bounds.</p>
</section>
<section id="points">
<h3><a class="toc-backref" href="#id23">POINTS</a><a class="headerlink" href="#points" title="Permalink to this heading"></a></h3>
<p>If a line or bar graph are not wanted and solely points are to be displayed then the POINTS method and the VERTEX2F method described above would be wanted. Of course, the points could be replaced by a bitmap or other glyph to indicate the points in the dataset.</p>
</section>
</section>
<section id="advanced-chapter">
<h2><a class="toc-backref" href="#id24">Advanced Chapter</a><a class="headerlink" href="#advanced-chapter" title="Permalink to this heading"></a></h2>
<p>In this chapter more advanced graph drawing options are explored.</p>
<p>When sending large data sets to the BT82x it is normal to compress the data for transfer using the coprocessor hardware compression to reduce transfer times. However, it is still possible to write directly into memory if that is preferred.</p>
<p>Compressed data can be sent in the <a class="reference external" href="https://github.com/Bridgetek/python-bt82x-dev">https://github.com/Bridgetek/python-bt82x-dev</a> there are API commands called cmd_inflate and ram_cmd for an array or load for a file handle. The address in RAM_G to store the data in is passed in the cmd_inflate command.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Send the commands to the BT82x</span>
<span class="n">eve</span><span class="o">.</span><span class="n">cmd_inflate</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">eve</span><span class="o">.</span><span class="n">ram_cmd</span><span class="p">(</span><span class="n">zlib</span><span class="p">(</span><span class="n">vertex</span><span class="o">.</span><span class="n">tobytes</span><span class="p">()))</span>
<span class="n">eve</span><span class="o">.</span><span class="n">finish</span><span class="p">()</span>
</pre></div>
</div>
<p>A write to the coprocessor or RAM_G can be achieved in a single SPI burst so this can be performed quickly. There will be options in the API for programming the BT82X for writing to RAM_G either through the coprocessor or directly.</p>
<section id="error-bars">
<h3><a class="toc-backref" href="#id25">Error Bars</a><a class="headerlink" href="#error-bars" title="Permalink to this heading"></a></h3>
<p>Other options could be to use LINES to draw error bars onto the graph.</p>
</section>
<section id="scrolling">
<h3><a class="toc-backref" href="#id26">Scrolling</a><a class="headerlink" href="#scrolling" title="Permalink to this heading"></a></h3>
<p>The BARGRAPH dataset memory can be “scrolled” by using the coprocessor CMD_MEMCPY command to move them a certain number of bytes from lower to higher memory addresses. Once the copy has completed the lower bytes can be written to add new data to the start of the trace.</p>
<p>The CMD_MEMCPY starts at the low address and moves byte-wise to higher addresses.</p>
<p>There are synchronisation commands in the coprocessor to ensure that the copy only occurs when the Render Engine is not accessing the data.</p>
</section>
<section id="subtractive-overlays">
<h3><a class="toc-backref" href="#id27">Subtractive Overlays</a><a class="headerlink" href="#subtractive-overlays" title="Permalink to this heading"></a></h3>
<p>A simple method to draw a line-style graph using the BARGRAPH method is to use a subtractive overlay. This will draw two graphs: an upper graph which is a set height above the actual data-set; and a lower graph which is below the data-set values. The upper graph is in the foreground colour while the lower graph is in the background colour. The 2 graphs are very similar but drawing the lower graph over the upper graph will result in a difference line remaining visible. The remaining difference is a line graph.</p>
<p>Since the 2 graphs will be of an identical length they can be treated as part of one data-set and be used to make 2 CELLs of a BITMAP like font characters. This allows one handle to be used for both graphs.</p>
<section id="id3">
<h4><a class="toc-backref" href="#id28">Example</a><a class="headerlink" href="#id3" title="Permalink to this heading"></a></h4>
<p>A good method of computing the 2 graphs in python and Numpy is as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">dataset_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">dataset_h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">prev_y</span> <span class="o">=</span> <span class="mi">256</span>
<span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
    <span class="c1"># Scale to 0-255, clip, invert Y</span>
    <span class="n">yi</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span> <span class="o">-</span> <span class="n">y</span><span class="p">))</span>
    <span class="c1"># addr0 holds the low Y, addr1 the high Y</span>
    <span class="k">if</span> <span class="n">yi</span> <span class="o">&lt;</span> <span class="n">prev_y</span><span class="p">:</span>
        <span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">yi</span><span class="p">,</span> <span class="n">prev_y</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">prev_y</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span>
    <span class="n">prev_y</span> <span class="o">=</span> <span class="n">yi</span>
    <span class="n">dataset_h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ecg8h</span><span class="p">,</span> <span class="n">lo</span><span class="p">)</span>
    <span class="n">dataset_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ecg8l</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="n">hi</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">dataset_combined</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">datset_h</span><span class="p">,</span> <span class="n">dataset_l</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
</pre></div>
</div>
<p>To display the two graphs (made from 400 data points) it is similar to the BARGRAPH described earlier except that the data-set is made from 2 sets of 400 points. Resulting in 800 points of data</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">BITMAP_HANDLE(0)</span>
<span class="go">BITMAP_SOURCE(0)</span>
<span class="go">BITMAP_SIZE_H(0, 0)</span>
<span class="go">BITMAP_SIZE(NEAREST, BORDER, BORDER, 400, 256)</span>
<span class="go">BITMAP_LAYOUT_H(0, 0)</span>
<span class="go">BITMAP_LAYOUT(BARGRAPH, 400, 1)</span>
<span class="go">BEGIN(BITMAPS)</span>
<span class="go">BITMAPHANDLE(0)</span>
<span class="go">COLOR_RGB(0, 255, 0)</span>
<span class="go">CELL(0)</span>
<span class="go">VERTEX2F(10, 10)</span>
<span class="go">CELL(1)</span>
<span class="go">VERTEX2F(10, 10)</span>
</pre></div>
</div>
<p>The resulting line graph will look like this:</p>
<img alt="Subtractive Overlay Example." src="_images/subtractive.png" />
<p><strong>Figure 9 Subtractive Overlay Example</strong></p>
</section>
<section id="id4">
<h4><a class="toc-backref" href="#id29">Discussion</a><a class="headerlink" href="#id4" title="Permalink to this heading"></a></h4>
<p>The line graph obtained is not ant-aliased and may lose some resolution but is a fast and efficient to draw and takes up little display list memory.</p>
</section>
</section>
<section id="precomputed-display-list">
<h3><a class="toc-backref" href="#id30">Precomputed Display List</a><a class="headerlink" href="#precomputed-display-list" title="Permalink to this heading"></a></h3>
<p>Premade display list entries can be generated on a host MCU and copied into RAM_G. The coprocessor can add the entries from RAM_G directly to the display list using the CMD_APPEND command.</p>
<section id="id5">
<h4><a class="toc-backref" href="#id31">Example</a><a class="headerlink" href="#id5" title="Permalink to this heading"></a></h4>
<p>One method of generating an array of VERTEX2F commands using python and Numpy would be:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="c1"># Create numpy array for C type uint32_t</span>
<span class="n">vertex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;&lt;I&#39;</span><span class="p">)</span>
<span class="c1"># Add a VERTEX_FORMAT(2) command (1/4 pixel precision)</span>
<span class="n">vertex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="mh">0x27000002</span><span class="p">)</span>
<span class="c1"># Add a BEGIN(LINE_STRIP) command</span>
<span class="n">vertex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="mh">0x1f000004</span><span class="p">)</span>
<span class="c1"># For each point in the data set</span>
<span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="n">dataset</span><span class="p">:</span>
    <span class="c1"># Add a VERTEX2F(x,y) command</span>
    <span class="n">vertex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="mh">0x40000000</span> <span class="o">+</span> <span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x7ffff</span><span class="p">)</span> <span class="o">+</span>
            <span class="p">(((</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">15</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x3fff8000</span><span class="p">))</span>
<span class="c1"># Finally add an END() command</span>
<span class="n">vertex</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="mh">0x21000000</span><span class="p">)</span>
</pre></div>
</div>
<p>This will convert a dataset containing an iterable array of (x,y) coordinates into vertex commands for the BT82x RAM_G.</p>
<p>To enact the commands in a display list, first it is necessary to send the commands to RAM_G. The method to achieve this is shown in the documentation of the API chosen to program the BT82x.</p>
<p>Then to add the commands from RAM_G to the display list the CMD_APPEND coprocessor command is called with the address of the start of the list and the number of bytes in the list. The length must be a multiple of 4 since each display list command is a 32-bit integer.</p>
</section>
<section id="id6">
<h4><a class="toc-backref" href="#id32">Discussion</a><a class="headerlink" href="#id6" title="Permalink to this heading"></a></h4>
<p>This method relies on using the host MCU to perform translations to make a display list in memory which is transferred to the BT82x later. The chosen API used to program the BT82x can be reused to write to host MCU memory. It also has the advantage of being able to filter or process the graph for efficiency – perform point reduction or band-pass filtering.</p>
<p>There is a small advantage in using this method in that data is compressed in transit and for larger sets of data will be faster than writing the display list directly.
The VERTEX2F data will still be in memory for subsequent passes if it is to be reused another CMD_APPEND can be issued to the coprocessor when another display list is made.</p>
<p>Lines cannot be “scrolled” simply though since x,y coordinates are inherent in the VERTEX2F commands. It is possible to use a window on the memory storing the VERTEX2F commands and VERTEX_TRANSLATE_X to give the appearance of scrolling while data is appended from a moving address. This is harder to setup and use but a valid method of use.</p>
</section>
</section>
</section>
<section id="appendix-a-revision-history">
<h2><a class="toc-backref" href="#id33">Appendix A - Revision History</a><a class="headerlink" href="#appendix-a-revision-history" title="Permalink to this heading"></a></h2>
<p>Document Title: Drawing Graphs on the BT82x</p>
<p>Product Page: <a class="reference external" href="https://brtchip.com/product/bt820b/">https://brtchip.com/product/bt820b/</a></p>
<table class="colwidths-given docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 50%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Revision</p></th>
<th class="head"><p>Changes</p></th>
<th class="head"><p>Date</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1.0</p></td>
<td><p>Initial Release</p></td>
<td><p>16/04/2025</p></td>
</tr>
</tbody>
</table>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Bridgetek Pte.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>